{"version":3,"sources":["../../src/controllers/otp.controller.ts"],"sourcesContent":["import { Request, Response } from \"express\";\r\nimport OtpModel from \"../models/otp.model\";\r\nimport { OtpDocument } from \"@interfaces/otp.interface\";\r\nimport ServiceProviderManager from \"../services/service-provider.manager\";\r\n\r\nclass OtpController {\r\n\r\n\tprivate readonly MAX_FAILED_ATTEMPTS = 5;\r\n\tprivate readonly LOCKOUT_DURATION_MINUTES = 15;\r\n\r\n\t\r\n\t// Method to generate and send OTP\r\n\tpublic generateOtp = async (\r\n\t\treq: Request,\r\n\t\tres: Response,\r\n\t): Promise<Response<any, Record<string, any>>> => {\r\n\t\ttry {\r\n\t\t\tconst { identifier } = req.body;\r\n\t\t\t// Check if the user is locked out due to too many failed attempts\r\n\t\t\tconst lockedUser: OtpDocument | null = await OtpModel.findOne({\r\n\t\t\t\tidentifier,\r\n\t\t\t\tlockoutUntil: { $gt: new Date() },\r\n\t\t\t});\r\n\r\n\t\t\tif (lockedUser && lockedUser.lockoutUntil) {\r\n\t\t\t\tconst lockoutRemainingMinutes = Math.ceil(\r\n\t\t\t\t\t(lockedUser.lockoutUntil.getTime() - new Date().getTime()) /\r\n\t\t\t\t\t\t(60 * 1000),\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn res.status(400).send({\r\n\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\terror: \"Verification Limit Exceeded\",\r\n\t\t\t\t\tmessage: `You have exceeded the maximum verification attempts. Please try again after ${lockoutRemainingMinutes} minutes.`,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Generate a random OTP\r\n\t\t\tconst otp = Math.floor(100000 + Math.random() * 900000);\r\n\r\n\r\n\t\t\tconst providers = ServiceProviderManager.getProviders();\r\n\r\n      let success = false;\r\n      let serviceProviderResponse: any;\r\n\r\n      for (const currentProvider of providers) {\r\n        try {\r\n          serviceProviderResponse = await currentProvider.instance.sendOTP(\r\n            identifier,\r\n            otp\r\n          );\r\n          success = true;\r\n          break;\r\n        } catch (error) {\r\n          console.error(\r\n            `Failed to send OTP with ${currentProvider.name}: ${error.message}`\r\n          );\r\n        }\r\n      }\r\n\r\n      if (!success) {\r\n        const nextProvider = await ServiceProviderManager.switchProvider();\r\n        serviceProviderResponse = await nextProvider.instance.sendOTP(\r\n          identifier,\r\n          otp\r\n        );\r\n      }\r\n\r\n\t\t\tconst otpRecord: OtpDocument | null = await OtpModel.findOne({\r\n\t\t\t\tidentifier,\r\n\t\t\t});\r\n\r\n\t\t\tif (otpRecord) {\r\n\t\t\t\t// Update existing OTP record\r\n\t\t\t\totpRecord.passwords.push({\r\n\t\t\t\t\tcode: otp,\r\n\t\t\t\t\texpiresAt: new Date(Date.now() + 5 * 60 * 1000),\r\n\t\t\t\t\tverified: false,\r\n\t\t\t\t\trequestedAt: new Date(),\r\n\t\t\t\t\tserviceProvider: \"\",\r\n\t\t\t\t\tserviceProviderResponse: undefined,\r\n\t\t\t\t});\r\n\t\t\t\totpRecord.failedAttempts = 0;\r\n\t\t\t\tawait otpRecord.save();\r\n\t\t\t} else {\r\n\t\t\t\t// Create a new OTP record for the user\r\n\t\t\t\tconst sendOTP = new OtpModel({\r\n\t\t\t\t\tidentifier,\r\n\t\t\t\t\tpasswords: [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcode: otp,\r\n\t\t\t\t\t\t\texpiresAt: new Date(Date.now() + 5 * 60 * 1000),\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t],\r\n\t\t\t\t\tfailedAttempts: 0,\r\n\t\t\t\t});\r\n\t\t\t\tawait sendOTP.save();\r\n\t\t\t}\r\n\r\n\t\t\tres.status(200).send({\r\n\t\t\t\tmessage: \"OTP sent successfully\",\r\n\t\t\t\tsuccess: true,\r\n\t\t\t});\r\n\t\t} catch (error: unknown) {\r\n\t\t\tthis.handleErrorResponse(\r\n\t\t\t\tres,\r\n\t\t\t\terror,\r\n\t\t\t\t\"generateOtp service provider Key Error\",\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t};\r\n\r\n\t// Method to verify the user-entered OTP\r\n\tpublic verifyOtp = async (\r\n\t\treq: Request,\r\n\t\tres: Response,\r\n\t): Promise<Response<any, Record<string, any>>> => {\r\n\t\ttry {\r\n\t\t\tconst { identifier, userEnteredOTP } = req.body;\r\n\r\n\t\t\tconst otpRecord: OtpDocument | null = await OtpModel.findOne({\r\n\t\t\t\tidentifier,\r\n\t\t\t});\r\n\t\t\t// Check if the OTP record exists and contains passwords\r\n\t\t\tif (\r\n\t\t\t\t!otpRecord ||\r\n\t\t\t\t!otpRecord.passwords ||\r\n\t\t\t\totpRecord.passwords.length === 0\r\n\t\t\t) {\r\n\t\t\t\treturn res.status(404).send({\r\n\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\terror: \"OTP not found\",\r\n\t\t\t\t\tmessage: \"Please generate a new OTP.\",\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Check if the user is locked out due to too many failed attempts\r\n\t\t\tif (otpRecord.failedAttempts >= this.MAX_FAILED_ATTEMPTS) {\r\n\t\t\t\tconst lockoutEndTime = new Date(otpRecord.lockoutUntil || \"\");\r\n\r\n\t\t\t\tif (lockoutEndTime > new Date()) {\r\n\t\t\t\t\tconst remainingLockoutTime = Math.ceil(\r\n\t\t\t\t\t\t(lockoutEndTime.getTime() - new Date().getTime()) /\r\n\t\t\t\t\t\t\t(this.LOCKOUT_DURATION_MINUTES * 60 * 1000),\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\treturn res.status(403).send({\r\n\t\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\t\terror: \"Account locked\",\r\n\t\t\t\t\t\tmessage: `Too many failed attempts. Try again after ${remainingLockoutTime} minutes.`,\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\totpRecord.failedAttempts = 0;\r\n\t\t\t\t\totpRecord.lockoutUntil = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Get the latest OTP from the record in descending order\r\n\t\t\tconst latestOTP = otpRecord.passwords.slice(-1)[0];\r\n\t\t\t// Check if the latest OTP has already been verified\r\n\t\t\tif (latestOTP.verified) {\r\n\t\t\t\treturn res.status(400).send({\r\n\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\terror: \"Invalid OTP\",\r\n\t\t\t\t\tmessage: \"This OTP has already been used.\",\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tconst expirationTime = new Date(\r\n\t\t\t\tlatestOTP.expiresAt.getTime() +\r\n\t\t\t\t\tthis.LOCKOUT_DURATION_MINUTES * 60 * 1000,\r\n\t\t\t);\r\n\r\n\t\t\tif (expirationTime < new Date()) {\r\n\t\t\t\treturn res.status(400).send({\r\n\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\terror: \"OTP expired\",\r\n\t\t\t\t\tmessage: \"Please generate a new OTP.\",\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Verify the user-entered OTP\r\n\t\t\tif (latestOTP.code === userEnteredOTP) {\r\n\t\t\t\tlatestOTP.verified = true;\r\n\t\t\t\totpRecord.failedAttempts = 0;\r\n\t\t\t\totpRecord.lockoutUntil = null;\r\n\t\t\t} else {\r\n\t\t\t\totpRecord.failedAttempts += 1;\r\n\r\n\t\t\t\tif (otpRecord.failedAttempts >= this.MAX_FAILED_ATTEMPTS) {\r\n\t\t\t\t\totpRecord.lockoutUntil = new Date(\r\n\t\t\t\t\t\tDate.now() + this.LOCKOUT_DURATION_MINUTES * 60 * 1000,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tawait otpRecord.save();\r\n\r\n\t\t\tif (latestOTP.verified) {\r\n\t\t\t\treturn res.status(200).send({\r\n\t\t\t\t\tsuccess: true,\r\n\t\t\t\t\tmessage: \"OTP verified successfully\",\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tconst response: {\r\n\t\t\t\t\tsuccess: false;\r\n\t\t\t\t\terror: \"Invalid OTP\";\r\n\t\t\t\t\tmessage: \"Please enter a valid OTP.\";\r\n\t\t\t\t\tlockout: { until: Date; remainingTime: number } | null;\r\n\t\t\t\t} = {\r\n\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\terror: \"Invalid OTP\",\r\n\t\t\t\t\tmessage: \"Please enter a valid OTP.\",\r\n\t\t\t\t\tlockout: null,\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Include lockout information in the response if applicable\r\n\t\t\t\tif (otpRecord.lockoutUntil) {\r\n\t\t\t\t\tconst remainingLockoutTime = Math.ceil(\r\n\t\t\t\t\t\t(otpRecord.lockoutUntil.getTime() -\r\n\t\t\t\t\t\t\tnew Date().getTime()) /\r\n\t\t\t\t\t\t\t(60 * 1000),\r\n\t\t\t\t\t);\r\n\t\t\t\t\tresponse.lockout = {\r\n\t\t\t\t\t\tuntil: otpRecord.lockoutUntil,\r\n\t\t\t\t\t\tremainingTime: remainingLockoutTime,\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn res.status(400).send(response);\r\n\t\t\t}\r\n\t\t} catch (error: unknown) {\r\n\t\t\tthis.handleErrorResponse(res, error, \"verifyOtp\");\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t};\r\n\r\n\tprivate handleErrorResponse(\r\n\t\tres: Response,\r\n\t\terror: unknown,\r\n\t\tmethodName: string,\r\n\t): void {\r\n\t\tconst logMessage = `Error in ${methodName}:`;\r\n\r\n\t\tif (error instanceof Error) {\r\n\t\t\tconsole.error(`${logMessage} ${error.message}`);\r\n\t\t\tres.status(500).send({\r\n\t\t\t\tsuccess: false,\r\n\t\t\t\terror: \"Internal server error\",\r\n\t\t\t\tmessage: error.message,\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tconsole.error(`${logMessage} An unknown error occurred.`);\r\n\t\t\tres.status(500).send({\r\n\t\t\t\tsuccess: false,\r\n\t\t\t\terror: \"Internal server error\",\r\n\t\t\t\tmessage: \"An unknown error occurred\",\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default OtpController;\r\n"],"names":["OtpController","handleErrorResponse","res","error","methodName","logMessage","Error","console","message","status","send","success","MAX_FAILED_ATTEMPTS","LOCKOUT_DURATION_MINUTES","generateOtp","req","identifier","body","lockedUser","OtpModel","findOne","lockoutUntil","$gt","Date","lockoutRemainingMinutes","Math","ceil","getTime","otp","floor","random","providers","ServiceProviderManager","getProviders","serviceProviderResponse","currentProvider","instance","sendOTP","name","nextProvider","switchProvider","otpRecord","passwords","push","code","expiresAt","now","verified","requestedAt","serviceProvider","undefined","failedAttempts","save","verifyOtp","userEnteredOTP","length","lockoutEndTime","remainingLockoutTime","latestOTP","slice","expirationTime","response","lockout","until","remainingTime"],"mappings":"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"}